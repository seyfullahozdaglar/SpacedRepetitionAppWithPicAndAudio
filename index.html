<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Vocabulary Flashcards</title>
    <style>
        :root {
            --primary: #4361ee;
            --secondary: #3a0ca3;
            --success: #4cc9f0;
            --danger: #f72585;
            --warning: #fca311;
            --light: #f8f9fa;
            --card-bg: #ffffff;
            --stat-bg: var(--light);
            --header-border: #eeeeee;
            --option-hover-bg: #f0f4ff;
            --option-border: #eeeeee;
            --row-hover: #f5f5f5;
            --list-item-hover: #e9ecef;
            --active-list-bg: #e0f7fa;
            --border-color: #dddddd;
            --muted: #6c757d;
            --th-hover: #e9ecef;
            --delete-hover-bg: rgba(0,0,0,0.05);
            --box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            --burger-color: #1f2937;
            --burger-border-color: rgba(0,0,0,0.12);
            --burger-hover-bg: rgba(67,97,238,0.06);
        }
        body.night-mode {
            --bg: #0f1724;
            --text: #e6eef8;
            --card-bg: #0b1220;
            --light: rgba(255,255,255,0.02);
            --stat-bg: rgba(255,255,255,0.02);
            --header-border: rgba(255,255,255,0.06);
            --option-hover-bg: rgba(255,255,255,0.03);
            --option-border: rgba(255,255,255,0.06);
            --row-hover: rgba(255,255,255,0.02);
            --list-item-hover: rgba(255,255,255,0.02);
            --active-list-bg: rgba(67,97,238,0.08);
            --border-color: rgba(255,255,255,0.06);
            --muted: #9aa7bf;
            --th-hover: rgba(255,255,255,0.03);
            --delete-hover-bg: rgba(255,255,255,0.03);
            --box-shadow: 0 6px 12px rgba(0,0,0,0.45);
            --burger-color: #e6eef8;
            --burger-border-color: rgba(255,255,255,0.12);
            --burger-hover-bg: rgba(255,255,255,0.03);
        }
        * { box-sizing: border-box; margin:0; padding:0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        body { background-color: var(--bg, #f5f7ff); color: var(--text, var(--dark, #212529)); line-height: 1.6; padding: 20px; min-height: 100vh; }
        .container { max-width: 1000px; margin: 0 auto; background: var(--card-bg); border-radius: 8px; box-shadow: var(--box-shadow); padding: 20px; }
        header { text-align: center; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 1px solid var(--header-border); display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; }
        h1 { color: var(--primary); margin-bottom: 10px; }
        header p { color: var(--muted); }
        .stats-container { display:flex; justify-content:space-around; margin:20px 0; flex-wrap:wrap; }
        .stat-box { background: var(--stat-bg); border-radius:8px; padding:15px; margin:10px; text-align:center; flex:1; min-width:150px; box-shadow:0 2px 4px rgba(0,0,0,0.05); color:var(--text); }
        .stat-number { font-size:24px; font-weight:bold; color:var(--primary); }
        .controls { display:flex; flex-direction:column; gap:15px; margin:20px 0; }
        .control-group { display:flex; flex-wrap:wrap; gap:10px; align-items:center; justify-content:center; }
        button { padding:12px 20px; border:none; border-radius:8px; background-color:var(--primary); color:white; font-weight:bold; cursor:pointer; transition:all 0.3s ease; }
        button:hover { background-color:var(--secondary); transform:translateY(-2px); }
        button:disabled { background-color:var(--muted); cursor:not-allowed; transform:none; }
        button.danger { background-color:var(--danger); }
        #nightModeToggle { padding:8px 12px; font-size:16px; line-height:1; display:inline-flex; align-items:center; justify-content:center; background:transparent; color:var(--text); border:1px solid var(--option-border); border-radius:8px; transition:background-color 0.2s, transform 0.15s; }
        #nightModeToggle:hover { background-color:var(--option-hover-bg); transform:translateY(-2px); }
        select, input, textarea { padding:10px; border:1px solid var(--border-color); border-radius:8px; background:transparent; color:var(--text); }
        textarea { min-height:140px; width:100%; resize:vertical; }
        .view { display:none; }
        .view.active { display:block; }
        .card { background:var(--card-bg); border-radius:8px; box-shadow:var(--box-shadow); padding:20px; margin:20px 0; text-align:center; position:relative; color:var(--text); }
        .question { font-size:24px; margin-bottom:20px; min-height:60px; display:flex; align-items:center; justify-content:center; gap:10px; }
        .note-display { margin:10px 0; padding:10px; background-color: rgba(67,97,238,0.05); border-left:3px solid var(--primary); border-radius:4px; text-align:left; font-size:14px; color:var(--muted); }
        .options { display:grid; grid-template-columns:1fr 1fr; gap:10px; margin:20px 0; }
        .option { padding:15px; border:2px solid var(--option-border); border-radius:8px; cursor:pointer; transition:all 0.2s ease; background:transparent; color:var(--text); min-height:80px; display:flex; flex-direction:column; align-items:center; justify-content:center; text-align:center; }
        .option:hover { border-color:var(--primary); background-color:var(--option-hover-bg); }
        .option.correct { background-color:#d4edda; border-color:#c3e6cb; color:#155724; }
        .option.incorrect { background-color:#f8d7da; border-color:#f5c6cb; color:#721c24; }
        .option img { max-height:100px; width:auto; display:block; margin-bottom:8px; border-radius:6px; max-width:100%; object-fit:contain; }
        .option .opt-text { font-size:16px; word-break:break-word; }
        .progress { margin:20px 0; font-weight:bold; color:var(--muted); }
        .feedback { margin:20px 0; padding:15px; border-radius:8px; text-align:center; font-weight:bold; }
        .feedback.correct { background-color:#d4edda; color:#155724; }
        .feedback.incorrect { background-color:#f8d7da; color:#721c24; }
        .summary { text-align:center; margin:20px 0; }
        table { width:100%; border-collapse:collapse; margin:20px 0; color:var(--text); }
        th, td { padding:12px; text-align:left; border-bottom:1px solid var(--border-color); cursor:pointer; }
        th { background-color:var(--light); font-weight:bold; position:relative; color:var(--text); }
        th:hover { background-color:var(--th-hover); }
        th.sorted-asc::after { content:" ↑"; font-weight:bold; }
        th.sorted-desc::after { content:" ↓"; font-weight:bold; }
        tr:hover { background-color:var(--row-hover); }
        .import-section { margin:20px 0; padding:20px; border:2px dashed var(--border-color); border-radius:8px; text-align:center; }
        .badge { display:inline-block; padding:3px 8px; border-radius:12px; font-size:12px; font-weight:bold; margin-left:5px; }
        .badge.success { background-color:#d4edda; color:#155724; }
        .badge.warning { background-color:#fff3cd; color:#856404; }
        .badge.danger { background-color:#f8d7da; color:#721c24; }
        .single-add-form { margin:20px 0; padding:20px; border:2px solid var(--option-border); border-radius:8px; }
        .form-group { margin-bottom:15px; }
        .form-group label { display:block; margin-bottom:5px; font-weight:bold; color:var(--text); }
        .form-group input { width:100%; padding:10px; border:1px solid var(--border-color); border-radius:8px; background:transparent; color:var(--text); }
        .list-management { margin:20px 0; }
        .list-item { padding:10px; margin:5px 0; background:var(--stat-bg); border-radius:8px; cursor:pointer; display:flex; justify-content:space-between; align-items:center; color:var(--text); }
        .list-item.active { background-color:var(--active-list-bg); border-left:4px solid var(--primary); }
        .list-item:hover { background-color:var(--list-item-hover); }
        .list-item .delete-list-btn { background:transparent; border:none; cursor:pointer; font-size:16px; padding:6px; border-radius:6px; color:var(--text); }
        .list-item .delete-list-btn:hover { background:var(--delete-hover-bg); }
        .card-actions { display:flex; justify-content:center; gap:10px; margin-top:15px; }
        .card-actions button { padding:8px 15px; font-size:14px; }
        .action-buttons { display:flex; gap:5px; }
        .action-buttons button { padding:5px 10px; font-size:12px; }
        .note-modal { display:none; position:fixed; top:0; left:0; width:100%; height:100%; background-color:rgba(0,0,0,0.5); z-index:2000; justify-content:center; align-items:center; }
        .note-modal.active { display:flex; }
        .note-modal-content { background-color:var(--card-bg); padding:20px; border-radius:8px; width:90%; max-width:500px; box-shadow:var(--box-shadow); }
        .note-modal h3 { margin-bottom:15px; color:var(--primary); }
        .note-modal textarea { width:100%; min-height:100px; margin-bottom:15px; resize:vertical; }
        .note-modal-actions { display:flex; justify-content:flex-end; gap:10px; }
        .side-nav { position:fixed; left:0; top:0; bottom:0; width:300px; background:var(--card-bg); box-shadow:2px 0 12px rgba(0,0,0,0.12); transition:transform 260ms ease; z-index:1001; padding:18px; overflow-y:auto; transform:translateX(-100%); will-change:transform; }
        .side-nav.open { transform:translateX(0); }
        .side-nav h2 { margin-bottom:12px; color:var(--primary); }
        .side-nav .control-group { justify-content:stretch; flex-direction:column; }
        .side-nav .control-group input, .side-nav .control-group button { width:100%; }
        .screen-overlay { position:fixed; inset:0; background:rgba(0,0,0,0.35); display:none; z-index:1000; pointer-events:none; }
        .screen-overlay.show { display:block; pointer-events:auto; }
        #burgerBtn { background:transparent; border:1px solid var(--burger-border-color); padding:8px 10px; border-radius:8px; font-size:18px; display:inline-flex; align-items:center; justify-content:center; cursor:pointer; margin-right:8px; color:var(--burger-color); }
        #burgerBtn:hover { background:var(--burger-hover-bg); transform:translateY(-2px); }
        @media (max-width:600px) { .options { grid-template-columns:1fr; } .stat-box { min-width:120px; } header { flex-direction:column; gap:10px; } .card-actions { flex-direction:column; } .side-nav { width:85%; } }
        /* small styles for play/record icons */
        .icon-btn { background:transparent; border:1px solid var(--option-border); padding:6px 10px; border-radius:8px; cursor:pointer; color:var(--text); display:inline-flex; align-items:center; gap:6px; }
        .icon-btn:disabled { opacity:0.5; cursor:not-allowed; }
    </style>
</head>
<body>
    <!-- Note Modal -->
    <div id="noteModal" class="note-modal">
        <div class="note-modal-content">
            <h3 id="noteModalTitle">Add Note</h3>
            <textarea id="noteInput" placeholder="Enter your note here..."></textarea>
            <div class="note-modal-actions">
                <button id="cancelNoteBtn">Cancel</button>
                <button id="saveNoteBtn" class="success">Save Note</button>
            </div>
        </div>
    </div>

    <!-- Side navigation (lists + create list) -->
    <div id="sideNav" class="side-nav" aria-hidden="true">
        <h2>Your Lists</h2>
        <div class="lists-inner">
            <div id="listsContainer" class="control-group"></div>
        </div>
        <div class="control-group" style="margin-top:12px;">
            <input type="text" id="newListName" placeholder="New list name">
            <button id="createListBtn">Create New List</button>
        </div>
    </div>

    <!-- overlay -->
    <div id="overlay" class="screen-overlay" tabindex="-1"></div>

    <div class="container">
        <header>
            <div style="display:flex; align-items:center; gap:12px;">
                <button id="burgerBtn" aria-label="Open lists menu">☰</button>
                <div>
                    <h1>Vocabulary Flashcards</h1>
                    <p>Learn and practice vocabulary with spaced repetition</p>
                </div>
            </div>
            <div class="control-group" style="gap:8px;">
                <label for="languageSelect">Language:</label>
                <select id="languageSelect">
                    <option value="en">English</option>
                    <option value="pl">Polish</option>
                    <option value="tr">Turkish</option>
                </select>
                <button id="nightModeToggle" title="Toggle night mode">🌙</button>
            </div>
        </header>

        <!-- Dashboard View -->
        <div id="dashboardView" class="view active">
            <div class="stats-container">
                <div class="stat-box">
                    <div class="stat-label">Total Cards</div>
                    <div id="totalCards" class="stat-number">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Ready to Practice</div>
                    <div id="readyToPractice" class="stat-number">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Never Practiced</div>
                    <div id="neverPracticed" class="stat-number">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Known Words</div>
                    <div id="knownWords" class="stat-number">0</div>
                </div>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label for="batchSize">Batch Size:</label>
                    <select id="batchSize">
                        <option value="5">5 cards</option>
                        <option value="10" selected>10 cards</option>
                        <option value="15">15 cards</option>
                        <option value="20">20 cards</option>
                    </select>

                    <label for="direction">Direction:</label>
                    <select id="direction">
                        <option value="wordToMeaning">Word → Meaning</option>
                        <option value="meaningToWord">Meaning → Word</option>
                    </select>
                </div>

                <div class="control-group">
                    <button id="learnNewBtn">Learn New Words</button>
                    <button id="practiceLearnedBtn">Practice Learned Words</button>
                    <button id="viewStatsBtn">View Statistics</button>
                </div>

                <div class="control-group">
                    <button id="importBtn">Import Cards</button>
                    <button id="exportMetadataBtn">Export Metadata</button>
                    <button id="importMetadataBtn">Import Metadata</button>
                    <button id="wipeAllBtn" class="danger">Wipe All Data</button>
                </div>
            </div>
        </div>

        <!-- Practice View -->
        <div id="practiceView" class="view">
            <div class="progress" id="progressText">Question 1 of 10</div>
            <div class="card">
                <div class="question" id="questionWrapper">
                    <div id="questionText"></div>
                    <button id="playAudioBtn" class="icon-btn" title="Play pronunciation" style="display:none;">🔊 Play</button>
                </div>

                <div id="noteDisplay" class="note-display" style="display: none;"></div>

                <div class="options" id="optionsContainer"></div>

                <div class="card-actions" id="cardActions" style="display: none;">
                    <button id="markKnownBtn" class="success">Mark as Known</button>
                    <button id="editNoteBtn">Add Note</button>
                    <button id="recordAudioBtn" class="icon-btn" title="Record pronunciation">🎙️ Record</button>
                    <button id="deleteCardBtn" class="danger">Delete Card</button>
                </div>
            </div>
            <div class="feedback" id="feedback" style="display: none;"></div>
            <button id="backToDashboardBtn" style="margin-top: 20px;">Back to Dashboard</button>
        </div>

        <!-- Summary View -->
        <div id="summaryView" class="view">
            <div class="summary">
                <h2 id="summaryTitle">Session Summary</h2>
                <p id="summaryText"></p>
                <button id="summaryBtn">Back to Dashboard</button>
            </div>
        </div>

        <!-- Statistics View -->
        <div id="statsView" class="view">
            <button id="backFromStatsBtn" style="margin-bottom: 20px;">Back to Dashboard</button>
            <h2>Card Statistics</h2>
            <div class="control-group">
                <button id="availableNowFilter" class="filter-btn active">Available Now</button>
                <button id="neverPracticedFilter" class="filter-btn">Never Practiced</button>
                <button id="knownWordsFilter" class="filter-btn">Known Words</button>
                <button id="allCardsFilter" class="filter-btn">All Cards</button>
            </div>
            <table id="statsTable">
                <thead>
                    <tr>
                        <th data-sort="word" data-sort-direction="none">Word</th>
                        <th data-sort="meaning" data-sort-direction="none">Meaning</th>
                        <th data-sort="note" data-sort-direction="none">Note</th>
                        <th data-sort="practiced" data-sort-direction="none">Practiced</th>
                        <th data-sort="successRate" data-sort-direction="none">Success Rate</th>
                        <th data-sort="nextDueAt" data-sort-direction="none">Next Due</th>
                        <th data-sort="known" data-sort-direction="none">Known</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody id="statsTableBody"></tbody>
            </table>
        </div>

        <!-- Import View -->
        <div id="importView" class="view">
            <h2>Import Cards</h2>

            <div class="single-add-form">
                <h3>Add Single Card</h3>
                <div class="form-group">
                    <label for="wordInput">Word:</label>
                    <input type="text" id="wordInput" placeholder="Enter word">
                </div>
                <div class="form-group">
                    <label for="meaningInput">Meaning:</label>
                    <input type="text" id="meaningInput" placeholder="Enter meaning">
                </div>
                <div class="form-group">
                    <label for="noteInputImport">Note (Optional):</label>
                    <input type="text" id="noteInputImport" placeholder="Enter note">
                </div>
                <div class="form-group">
                    <label for="imageInputImport">Image URL (Optional):</label>
                    <input type="text" id="imageInputImport" placeholder="https://example.com/pic.jpg">
                </div>
                <button id="addSingleCardBtn">Add Card</button>
            </div>

            <div class="import-section">
                <h3>Bulk Import</h3>
                <p>Import cards from a text file with format: <code>word // meaning // note // imageUrl</code> on each line (note and imageUrl are optional). Example image URL: <code>https://example.com/pic.jpg</code></p>
                <input type="file" id="fileInput" accept=".txt,.csv,text/plain,text/csv,application/vnd.ms-excel,application/octet-stream">
                <button id="processImportBtn" style="margin-top: 15px;">Process Import</button>

                <hr style="margin:20px 0;border:none;border-top:1px solid var(--border-color)">

                <p>Or paste pairs directly (one per line, format: <code>word // meaning // note // imageUrl</code>)</p>
                <textarea id="pasteInput" placeholder="e.g. apple // jabłko // A red fruit // https://example.com/apple.jpg"></textarea>
                <div style="margin-top:12px;">
                    <button id="processPasteBtn">Import Pasted</button>
                </div>
            </div>
            <div id="importResult" style="margin-top: 20px;"></div>
            <button id="backFromImportBtn" style="margin-top: 20px;">Back to Dashboard</button>
        </div>
    </div>

    <input type="file" id="metadataFileInput" accept=".csv,text/csv,application/csv,application/vnd.ms-excel,text/plain,application/octet-stream" style="position:absolute; left:-9999px; width:1px; height:1px; overflow:hidden;" aria-hidden="true">

    <script>
        // Data model and constants
        const INTERVALS = [60,300,720,1440,2880,4320,10080,20160,43200,129600,172800,216000,259200];
        const STORAGE_KEY = 'vocabularyFlashcards';
        const LISTS_STORAGE_KEY = 'vocabularyFlashcardsLists';
        const CURRENT_LIST_KEY = 'vocabularyFlashcardsCurrentList';
        const NIGHT_MODE_KEY = 'vocabularyFlashcardsNightMode';

        // State
        let cards = [];
        let lists = [];
        let currentListId = null;
        let currentSession = { cards:[], currentIndex:0, correctCount:0, type:'', direction:'wordToMeaning' };

        // Recording state
        let mediaRecorder = null;
        let recordedChunks = [];
        let mediaStream = null;

        // DOM
        const views = {
            dashboard: document.getElementById('dashboardView'),
            practice: document.getElementById('practiceView'),
            summary: document.getElementById('summaryView'),
            stats: document.getElementById('statsView'),
            import: document.getElementById('importView')
        };
        const sideNav = document.getElementById('sideNav');
        const overlay = document.getElementById('overlay');
        const burgerBtn = document.getElementById('burgerBtn');

        // Note modal
        const noteModal = document.getElementById('noteModal');
        const noteInput = document.getElementById('noteInput');
        const noteModalTitle = document.getElementById('noteModalTitle');
        const saveNoteBtn = document.getElementById('saveNoteBtn');
        const cancelNoteBtn = document.getElementById('cancelNoteBtn');

        // Practice view elements for audio
        const playAudioBtn = document.getElementById('playAudioBtn');
        const recordAudioBtn = document.getElementById('recordAudioBtn');

        function init() {
            loadLists();
            loadCards();
            updateDashboard();
            setupEventListeners();
            updateLanguageSelector();
            // night mode
            const savedNight = localStorage.getItem(NIGHT_MODE_KEY);
            applyNightMode(savedNight === 'true');

            // Ensure record button availability based on support
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia || typeof MediaRecorder === 'undefined') {
                if (recordAudioBtn) {
                    recordAudioBtn.disabled = true;
                    recordAudioBtn.title = 'Recording not supported by this browser';
                }
            }
        }

        function applyNightMode(enable) {
            if (enable) {
                document.body.classList.add('night-mode');
                const btn = document.getElementById('nightModeToggle');
                if (btn) btn.textContent = '☀️';
            } else {
                document.body.classList.remove('night-mode');
                const btn = document.getElementById('nightModeToggle');
                if (btn) btn.textContent = '🌙';
            }
        }
        function toggleNightMode() {
            const isNight = document.body.classList.toggle('night-mode');
            const btn = document.getElementById('nightModeToggle');
            if (btn) btn.textContent = isNight ? '☀️' : '🌙';
            localStorage.setItem(NIGHT_MODE_KEY, isNight ? 'true' : 'false');
        }

        // Lists
        function loadLists() {
            const storedLists = localStorage.getItem(LISTS_STORAGE_KEY);
            if (storedLists) lists = JSON.parse(storedLists);
            if (!lists || lists.length === 0) {
                lists = [{ id: generateId(), name: 'Default List', createdAt: new Date().toISOString() }];
                saveLists();
            }
            const storedCurrentListId = localStorage.getItem(CURRENT_LIST_KEY);
            currentListId = storedCurrentListId || lists[0].id;
            if (!lists.find(l => l.id === currentListId)) {
                currentListId = lists[0].id;
                localStorage.setItem(CURRENT_LIST_KEY, currentListId);
            }
            renderLists();
        }
        function saveLists() { localStorage.setItem(LISTS_STORAGE_KEY, JSON.stringify(lists)); }
        function renderLists() {
            const listsContainer = document.getElementById('listsContainer');
            if (!listsContainer) return;
            listsContainer.innerHTML = '';
            lists.forEach(list => {
                const listElement = document.createElement('div');
                listElement.className = `list-item ${list.id === currentListId ? 'active' : ''}`;
                const nameSpan = document.createElement('span');
                nameSpan.textContent = list.name;
                nameSpan.style.flex = '1';
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-list-btn';
                deleteBtn.title = 'Delete list';
                deleteBtn.type = 'button';
                deleteBtn.innerHTML = '🗑️';
                listElement.addEventListener('click', () => {
                    currentListId = list.id;
                    localStorage.setItem(CURRENT_LIST_KEY, currentListId);
                    loadCards();
                    renderLists();
                    updateDashboard();
                    closeSideNav();
                });
                (function attachDeleteHandlers(btn, listId) {
                    let handled = false;
                    const doDelete = (e) => {
                        if (e) { try{ e.stopPropagation(); }catch{} try{ e.preventDefault(); }catch{} }
                        if (handled) return;
                        handled = true;
                        deleteList(listId);
                        setTimeout(()=>{ handled=false; },400);
                    };
                    btn.addEventListener('click', doDelete);
                    btn.addEventListener('touchstart', doDelete, { passive:false });
                    btn.addEventListener('pointerdown', function(e){ if (e.pointerType==='mouse') return; doDelete(e); });
                })(deleteBtn, list.id);
                listElement.appendChild(nameSpan);
                listElement.appendChild(deleteBtn);
                listsContainer.appendChild(listElement);
            });
        }
        function deleteList(listId) {
            const toDelete = lists.find(l => l.id === listId);
            if (!toDelete) return;
            if (!confirm(`Delete the list "${toDelete.name}" and ALL its cards? This action cannot be undone.`)) return;
            lists = lists.filter(l => l.id !== listId);
            saveLists();
            const storedCardsStr = localStorage.getItem(STORAGE_KEY);
            let allCards = storedCardsStr ? JSON.parse(storedCardsStr) : [];
            allCards = allCards.filter(c => c.listId !== listId);
            localStorage.setItem(STORAGE_KEY, JSON.stringify(allCards));
            if (currentListId === listId) {
                if (lists.length > 0) {
                    currentListId = lists[0].id;
                    localStorage.setItem(CURRENT_LIST_KEY, currentListId);
                } else {
                    const defaultList = { id: generateId(), name: 'Default List', createdAt: new Date().toISOString() };
                    lists = [defaultList];
                    saveLists();
                    currentListId = defaultList.id;
                    localStorage.setItem(CURRENT_LIST_KEY, currentListId);
                }
            }
            loadCards();
            renderLists();
            updateDashboard();
            alert('List deleted.');
        }

        // Cards
        function loadCards() {
            const storedCards = localStorage.getItem(STORAGE_KEY);
            if (storedCards) {
                const allCards = JSON.parse(storedCards);
                cards = allCards.filter(card => card.listId === currentListId);
                cards = cards.map(card => {
                    if (card.known === undefined) card.known = false;
                    if (card.note === undefined) card.note = '';
                    if (card.image === undefined) card.image = '';
                    if (card.audio === undefined) card.audio = '';
                    return card;
                });
            } else cards = [];
        }
        function saveCards() {
            const storedCards = localStorage.getItem(STORAGE_KEY);
            let allCards = storedCards ? JSON.parse(storedCards) : [];
            allCards = allCards.filter(card => card.listId !== currentListId);
            allCards = allCards.concat(cards);
            localStorage.setItem(STORAGE_KEY, JSON.stringify(allCards));
        }

        function updateDashboard() {
            const totalCards = cards.length;
            const neverPracticed = cards.filter(card => !card.practiced && !card.known).length;
            const readyToPractice = cards.filter(card => isCardReadyToPractice(card) && !card.known).length;
            const knownWords = cards.filter(card => card.known).length;
            document.getElementById('totalCards').textContent = totalCards;
            document.getElementById('neverPracticed').textContent = neverPracticed;
            document.getElementById('readyToPractice').textContent = readyToPractice;
            document.getElementById('knownWords').textContent = knownWords;
            document.getElementById('learnNewBtn').disabled = neverPracticed === 0;
            document.getElementById('practiceLearnedBtn').disabled = readyToPractice === 0;
        }

        function isCardReadyToPractice(card) {
            if (!card.practiced || card.known) return false;
            const now = new Date();
            const dueDate = new Date(card.nextDueAt);
            return card.successRate < 0.7 || now >= dueDate;
        }

        function showView(viewName) {
            Object.keys(views).forEach(k => views[k].classList.remove('active'));
            views[viewName].classList.add('active');
        }

        function generateId(){ return Date.now().toString(36) + Math.random().toString(36).substring(2); }

        // Sessions
        function startLearnSession() {
            const batchSize = parseInt(document.getElementById('batchSize').value);
            const direction = document.getElementById('direction').value;
            const newWords = cards.filter(card => !card.practiced && !card.known);
            if (newWords.length === 0) { alert('No new words to learn!'); return; }
            const selectedCards = shuffleArray(newWords).slice(0, batchSize);
            currentSession = { cards:selectedCards, currentIndex:0, correctCount:0, type:'learn', direction };
            showPracticeCard();
            showView('practice');
        }
        function startPracticeSession() {
            const batchSize = parseInt(document.getElementById('batchSize').value);
            const direction = document.getElementById('direction').value;
            const readyCards = cards.filter(card => isCardReadyToPractice(card));
            if (readyCards.length === 0) { alert('No cards are ready to practice right now.'); return; }
            const selectedCards = shuffleArray(readyCards).slice(0, batchSize);
            currentSession = { cards:selectedCards, currentIndex:0, correctCount:0, type:'practice', direction };
            showPracticeCard();
            showView('practice');
        }

        // Show practice card and update audio UI
        function showPracticeCard() {
            const { currentIndex, cards: sessionCards, direction } = currentSession;
            const card = sessionCards[currentIndex];
            if (!card) { endSession(); return; }
            document.getElementById('progressText').textContent = `Question ${currentIndex + 1} of ${sessionCards.length}`;
            const isWordToMeaning = direction === 'wordToMeaning';
            document.getElementById('questionText').textContent = isWordToMeaning ? card.word : card.meaning;

            // note
            const noteDisplay = document.getElementById('noteDisplay');
            if (card.note && card.note.trim() !== '') { noteDisplay.textContent = card.note; noteDisplay.style.display = 'block'; }
            else { noteDisplay.style.display = 'none'; }

            const editNoteBtn = document.getElementById('editNoteBtn');
            editNoteBtn.textContent = card.note && card.note.trim() !== '' ? 'Edit Note' : 'Add Note';

            // options
            const optionsContainer = document.getElementById('optionsContainer');
            optionsContainer.innerHTML = '';
            const correctAnswer = isWordToMeaning ? card.meaning : card.word;
            const distractorCards = getDistractors(card, isWordToMeaning);
            const optionCards = shuffleArray([card, ...distractorCards]);
            optionCards.forEach(optionCard => {
                const optionElement = document.createElement('div');
                optionElement.className = 'option';
                const optionValue = isWordToMeaning ? optionCard.meaning : optionCard.word;
                optionElement.dataset.value = optionValue;
                optionElement.tabIndex = 0;
                if (optionCard.image && optionCard.image.trim() !== '') {
                    const img = document.createElement('img');
                    img.src = optionCard.image.trim();
                    img.onerror = function(){ this.style.display = 'none'; };
                    optionElement.appendChild(img);
                }
                const textSpan = document.createElement('div');
                textSpan.className = 'opt-text';
                textSpan.textContent = optionValue;
                optionElement.appendChild(textSpan);
                optionElement.addEventListener('click', ()=> checkAnswer(optionElement.dataset.value, correctAnswer));
                optionElement.addEventListener('keydown', (e)=> { if (e.key==='Enter' || e.key===' ') { e.preventDefault(); optionElement.click(); }});
                optionsContainer.appendChild(optionElement);
            });

            document.getElementById('cardActions').style.display = 'flex';
            document.getElementById('feedback').style.display = 'none';

            // Update audio UI: show/hide play button; set record button label
            updateAudioUIForCard(card);
        }

        function getDistractors(card, isWordToMeaning) {
            const otherCards = cards.filter(c => c.id !== card.id && c.listId === currentListId && !c.known);
            if (otherCards.length === 0) return [];
            const shuffled = shuffleArray(otherCards);
            return shuffled.slice(0,3);
        }

        function checkAnswer(selectedAnswer, correctAnswer) {
            const isCorrect = selectedAnswer === correctAnswer;
            const card = currentSession.cards[currentSession.currentIndex];
            card.timesShown = (card.timesShown || 0) + 1;
            if (isCorrect) card.correctCount = (card.correctCount || 0) + 1;
            else card.wrongCount = (card.wrongCount || 0) + 1;
            card.successRate = (card.correctCount || 0) / ((card.correctCount || 0) + (card.wrongCount || 0));
            card.lastAskedAt = new Date().toISOString();
            if (currentSession.type === 'learn') {
                card.practiced = true;
                card.scheduleIndex = 1;
            } else {
                if (isCorrect) card.scheduleIndex = Math.min((card.scheduleIndex || 0) + 1, INTERVALS.length - 1);
                else card.scheduleIndex = Math.max(0, (card.scheduleIndex || 0) - 1);
            }
            const intervalMinutes = INTERVALS[card.scheduleIndex || 0];
            const nextDueDate = new Date(); nextDueDate.setMinutes(nextDueDate.getMinutes() + intervalMinutes);
            card.nextDueAt = nextDueDate.toISOString();
            if (isCorrect) currentSession.correctCount++;
            const feedbackElement = document.getElementById('feedback');
            feedbackElement.textContent = isCorrect ? 'Correct!' : `Incorrect. The answer is: ${correctAnswer}`;
            feedbackElement.className = `feedback ${isCorrect ? 'correct' : 'incorrect'}`;
            feedbackElement.style.display = 'block';
            const options = document.querySelectorAll('.option');
            options.forEach(option => {
                option.style.pointerEvents = 'none';
                const val = option.dataset.value;
                if (val === correctAnswer) option.classList.add('correct');
                else if (val === selectedAnswer && !isCorrect) option.classList.add('incorrect');
            });
            setTimeout(()=>{
                currentSession.currentIndex++;
                if (currentSession.currentIndex < currentSession.cards.length) showPracticeCard();
                else endSession();
                saveCards();
            },700);
        }

        function endSession() {
            const { correctCount, cards: sessionCards, type } = currentSession;
            const totalQuestions = sessionCards.length;
            const accuracy = totalQuestions > 0 ? (correctCount / totalQuestions * 100).toFixed(1) : 0;
            document.getElementById('summaryTitle').textContent = type === 'learn' ? 'Learning Session Complete' : 'Practice Session Complete';
            document.getElementById('summaryText').textContent = `You got ${correctCount} out of ${totalQuestions} correct (${accuracy}% accuracy).`;
            showView('summary');
            updateDashboard();
        }

        function markCurrentCardAsKnown() {
            const card = currentSession.cards[currentSession.currentIndex];
            if (card) {
                card.known = true;
                saveCards();
                currentSession.currentIndex++;
                if (currentSession.currentIndex < currentSession.cards.length) showPracticeCard();
                else endSession();
            }
        }

        function deleteCurrentCard() {
            const card = currentSession.cards[currentSession.currentIndex];
            if (card && confirm(`Are you sure you want to delete the card "${card.word}"?`)) {
                currentSession.cards.splice(currentSession.currentIndex, 1);
                const cardIndex = cards.findIndex(c => c.id === card.id);
                if (cardIndex !== -1) {
                    cards.splice(cardIndex, 1);
                    saveCards();
                    updateDashboard();
                }
                if (currentSession.currentIndex < currentSession.cards.length) showPracticeCard();
                else if (currentSession.cards.length === 0) endSession();
                else { currentSession.currentIndex--; showPracticeCard(); }
            }
        }

        function showNoteModal() {
            const card = currentSession.cards[currentSession.currentIndex];
            if (!card) return;
            noteModalTitle.textContent = card.note && card.note.trim() !== '' ? 'Edit Note' : 'Add Note';
            noteInput.value = card.note || '';
            noteModal.classList.add('active');
            noteInput.focus();
        }
        function saveNote() {
            const card = currentSession.cards[currentSession.currentIndex];
            if (card) {
                card.note = noteInput.value.trim();
                saveCards();
                closeNoteModal();
                const noteDisplay = document.getElementById('noteDisplay');
                const editNoteBtn = document.getElementById('editNoteBtn');
                if (card.note && card.note.trim() !== '') {
                    noteDisplay.textContent = card.note;
                    noteDisplay.style.display = 'block';
                    editNoteBtn.textContent = 'Edit Note';
                } else {
                    noteDisplay.style.display = 'none';
                    editNoteBtn.textContent = 'Add Note';
                }
            }
        }
        function closeNoteModal() { noteModal.classList.remove('active'); noteInput.value = ''; }

        // Statistics UI & helpers
        function showStatistics(filter = 'availableNow') {
            const tableBody = document.getElementById('statsTableBody');
            tableBody.innerHTML = '';
            let filteredCards = [];
            switch(filter) {
                case 'availableNow': filteredCards = cards.filter(isCardReadyToPractice); break;
                case 'neverPracticed': filteredCards = cards.filter(card => !card.practiced && !card.known); break;
                case 'knownWords': filteredCards = cards.filter(card => card.known); break;
                default: filteredCards = [...cards];
            }
            const sortHeader = document.querySelector('th[data-sort-direction="asc"], th[data-sort-direction="desc"]');
            if (sortHeader) {
                const sortBy = sortHeader.dataset.sort;
                const sortDirection = sortHeader.dataset.sortDirection;
                filteredCards.sort((a,b)=> {
                    let valueA = a[sortBy];
                    let valueB = b[sortBy];
                    if (sortBy === 'nextDueAt') {
                        valueA = valueA ? new Date(valueA).getTime() : 0;
                        valueB = valueB ? new Date(valueB).getTime() : 0;
                    }
                    if (valueA < valueB) return sortDirection === 'asc' ? -1 : 1;
                    if (valueA > valueB) return sortDirection === 'asc' ? 1 : -1;
                    return 0;
                });
            }
            filteredCards.forEach(card => {
                const row = document.createElement('tr');
                const lastAsked = card.lastAskedAt ? new Date(card.lastAskedAt).toLocaleDateString() : 'Never';
                let nextDue = 'Not scheduled'; let dueBadge = '';
                if (card.nextDueAt) {
                    const dueDate = new Date(card.nextDueAt);
                    nextDue = dueDate.toLocaleString();
                    const now = new Date();
                    if (dueDate < now) dueBadge = '<span class="badge danger">Overdue</span>';
                    else if ((dueDate - now) < 24*60*60*1000) dueBadge = '<span class="badge warning">Due soon</span>';
                    else dueBadge = '<span class="badge success">Scheduled</span>';
                }
                let successRate = 'N/A'; let successBadge = '';
                if (card.practiced && (card.timesShown || 0) > 0) {
                    successRate = `${((card.successRate || 0) * 100).toFixed(1)}%`;
                    if ((card.successRate || 0) >= 0.7) successBadge = '<span class="badge success">Good</span>';
                    else if ((card.successRate || 0) >= 0.5) successBadge = '<span class="badge warning">Needs work</span>';
                    else successBadge = '<span class="badge danger">Poor</span>';
                }
                const knownStatus = card.known ? 'Yes' : 'No';
                const knownBadge = card.known ? '<span class="badge success">Known</span>' : '<span class="badge warning">Learning</span>';
                let noteDisplay = card.note || '';
                if (noteDisplay.length > 50) noteDisplay = noteDisplay.substring(0,50) + '...';
                row.innerHTML = `
                    <td>${card.word}</td>
                    <td>${card.meaning}</td>
                    <td>${noteDisplay}</td>
                    <td>${card.practiced ? 'Yes' : 'No'}</td>
                    <td>${successRate} ${successBadge}</td>
                    <td>${nextDue} ${dueBadge}</td>
                    <td>${knownStatus} ${knownBadge}</td>
                    <td class="action-buttons">
                        <button class="mark-known-btn" data-id="${card.id}">${card.known ? 'Mark Unknown' : 'Mark Known'}</button>
                        <button class="delete-card-btn danger" data-id="${card.id}">Delete</button>
                    </td>
                `;
                tableBody.appendChild(row);
            });
            document.querySelectorAll('.mark-known-btn').forEach(btn => {
                btn.addEventListener('click', (e)=> {
                    const cardId = e.target.dataset.id; toggleCardKnownStatus(cardId);
                });
            });
            document.querySelectorAll('.delete-card-btn').forEach(btn => {
                btn.addEventListener('click', (e)=> {
                    const cardId = e.target.dataset.id; deleteCardFromStats(cardId);
                });
            });
        }
        function toggleCardKnownStatus(cardId) {
            const card = cards.find(c => c.id === cardId);
            if (card) {
                card.known = !card.known;
                saveCards(); updateDashboard();
                const activeFilter = document.querySelector('.filter-btn.active').id;
                let filterType = 'all';
                if (activeFilter === 'availableNowFilter') filterType = 'availableNow';
                if (activeFilter === 'neverPracticedFilter') filterType = 'neverPracticed';
                if (activeFilter === 'knownWordsFilter') filterType = 'knownWords';
                showStatistics(filterType);
            }
        }
        function deleteCardFromStats(cardId) {
            const card = cards.find(c => c.id === cardId);
            if (card && confirm(`Are you sure you want to delete the card "${card.word}"?`)) {
                const cardIndex = cards.findIndex(c => c.id === cardId);
                if (cardIndex !== -1) {
                    cards.splice(cardIndex,1);
                    saveCards(); updateDashboard();
                    const activeFilter = document.querySelector('.filter-btn.active').id;
                    let filterType = 'all';
                    if (activeFilter === 'availableNowFilter') filterType = 'availableNow';
                    if (activeFilter === 'neverPracticedFilter') filterType = 'neverPracticed';
                    if (activeFilter === 'knownWordsFilter') filterType = 'knownWords';
                    showStatistics(filterType);
                }
            }
        }
        function sortTable(columnName) {
            const header = document.querySelector(`th[data-sort="${columnName}"]`);
            const currentDirection = header.dataset.sortDirection;
            document.querySelectorAll('th[data-sort]').forEach(h => { h.dataset.sortDirection = 'none'; h.classList.remove('sorted-asc','sorted-desc'); });
            if (currentDirection === 'none' || currentDirection === 'desc') { header.dataset.sortDirection = 'asc'; header.classList.add('sorted-asc'); }
            else { header.dataset.sortDirection = 'desc'; header.classList.add('sorted-desc'); }
            const activeFilter = document.querySelector('.filter-btn.active').id;
            let filterType = 'all';
            if (activeFilter === 'availableNowFilter') filterType = 'availableNow';
            if (activeFilter === 'neverPracticedFilter') filterType = 'neverPracticed';
            if (activeFilter === 'knownWordsFilter') filterType = 'knownWords';
            showStatistics(filterType);
        }

        // Import plain text (word // meaning // note // image)
        function importCards(file) {
            const reader = new FileReader();
            reader.onload = function(e) { parseAndImport(e.target.result); };
            reader.readAsText(file);
        }
        function parseAndImport(content) {
            const lines = content.split(/\r?\n/);
            let importedCount = 0, updatedCount = 0;
            lines.forEach(line => {
                const parts = line.split(/\s*\/\/\s*/).map(s => s.trim());
                if (parts.length < 2) return;
                const word = parts[0], meaning = parts[1];
                let note = '', image = '';
                if (parts.length === 3) note = parts[2];
                else if (parts.length >=4) { image = parts[parts.length-1]; note = parts.slice(2,parts.length-1).join(' // '); }
                if (word && meaning) {
                    const existingIndex = cards.findIndex(c => c.word === word && c.listId === currentListId);
                    if (existingIndex >= 0) {
                        cards[existingIndex].meaning = meaning;
                        cards[existingIndex].note = note;
                        if (image) cards[existingIndex].image = image;
                        updatedCount++;
                    } else {
                        cards.push({
                            id: generateId(), word, meaning, note, image: image || '', audio:'', practiced:false, known:false,
                            timesShown:0, correctCount:0, wrongCount:0, successRate:0, lastAskedAt:null, scheduleIndex:0, nextDueAt:null, listId: currentListId
                        });
                        importedCount++;
                    }
                }
            });
            saveCards(); updateDashboard();
            document.getElementById('importResult').innerHTML = `<div class="feedback correct">Import completed!<br>${importedCount} new cards imported<br>${updatedCount} existing cards updated</div>`;
        }

        // Add single card
        function addSingleCard() {
            const word = document.getElementById('wordInput').value.trim();
            const meaning = document.getElementById('meaningInput').value.trim();
            const note = document.getElementById('noteInputImport').value.trim();
            const image = document.getElementById('imageInputImport').value.trim();
            if (!word || !meaning) { alert('Please enter both word and meaning'); return; }
            const existingIndex = cards.findIndex(c => c.word === word && c.listId === currentListId);
            if (existingIndex >= 0) {
                cards[existingIndex].meaning = meaning;
                cards[existingIndex].note = note;
                if (image) cards[existingIndex].image = image;
                alert('Card updated successfully!');
            } else {
                cards.push({
                    id: generateId(), word, meaning, note, image: image || '', audio:'', practiced:false, known:false,
                    timesShown:0, correctCount:0, wrongCount:0, successRate:0, lastAskedAt:null, scheduleIndex:0, nextDueAt:null, listId: currentListId
                });
                alert('Card added successfully!');
            }
            document.getElementById('wordInput').value=''; document.getElementById('meaningInput').value=''; document.getElementById('noteInputImport').value=''; document.getElementById('imageInputImport').value='';
            saveCards(); updateDashboard();
        }

        // Create new list
        function createNewList() {
            const listName = document.getElementById('newListName').value.trim();
            if (!listName) { alert('Please enter a list name'); return; }
            const newList = { id: generateId(), name: listName, createdAt: new Date().toISOString() };
            lists.push(newList); saveLists();
            document.getElementById('newListName').value='';
            currentListId = newList.id; localStorage.setItem(CURRENT_LIST_KEY, currentListId);
            loadCards(); renderLists(); updateDashboard(); closeSideNav();
        }

        function wipeAllData() {
            if (confirm('Are you sure you want to delete all cards? This action cannot be undone.')) {
                cards = []; saveCards(); updateDashboard(); alert('All data has been wiped.');
            }
        }

        // Export metadata (CSV) — includes audio column now
        function exportMetadata() {
            const storedCards = localStorage.getItem(STORAGE_KEY);
            const allCards = storedCards ? JSON.parse(storedCards) : [];
            const storedLists = localStorage.getItem(LISTS_STORAGE_KEY);
            const allLists = storedLists ? JSON.parse(storedLists) : [];
            const currentList = localStorage.getItem(CURRENT_LIST_KEY);

            const header = ['type','id','word','meaning','note','image','audio','practiced','known','timesShown','correctCount','wrongCount','successRate','lastAskedAt','scheduleIndex','nextDueAt','listId','listName','createdAt'];
            let csvLines = [];
            csvLines.push(arrayToCsvLine(header));

            // lists
            allLists.forEach(list => {
                const line = ['list', list.id || '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', list.name || '', list.createdAt || ''];
                csvLines.push(arrayToCsvLine(line));
            });

            // cards
            allCards.forEach(card => {
                const list = allLists.find(l => l.id === card.listId);
                const listName = list ? list.name : '';
                const line = [
                    'card',
                    card.id || '',
                    card.word || '',
                    card.meaning || '',
                    card.note || '',
                    card.image || '',
                    card.audio || '',
                    card.practiced ? 'true' : 'false',
                    card.known ? 'true' : 'false',
                    card.timesShown || 0,
                    card.correctCount || 0,
                    card.wrongCount || 0,
                    card.successRate || 0,
                    card.lastAskedAt || '',
                    card.scheduleIndex || 0,
                    card.nextDueAt || '',
                    card.listId || '',
                    listName,
                    ''
                ];
                csvLines.push(arrayToCsvLine(line));
            });

            const csvContent = csvLines.join('\n');
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            const date = new Date().toISOString().slice(0,10);
            link.setAttribute('href', url);
            link.setAttribute('download', `vocabulary-flashcards-backup-${date}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            alert('Metadata exported successfully!');
        }
        function arrayToCsvLine(arr) { return arr.map(f => escapeCsvField(f)).join(','); }
        function escapeCsvField(field) {
            if (field === null || field === undefined) return '';
            const string = String(field);
            if (string.includes(',') || string.includes('"') || string.includes('\n')) {
                return '"' + string.replace(/"/g, '""') + '"';
            }
            return string;
        }

        // Import metadata CSV — maps audio field
        function importMetadata(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const content = e.target.result;
                const lines = content.split(/\r?\n/);
                let importedLists = [];
                let importedCards = [];
                let startIndex = 0;
                if (lines.length > 0) {
                    const first = lines[0].trim().toLowerCase();
                    if (first.startsWith('type,') || (first.includes('word') && first.includes('meaning'))) startIndex = 1;
                }
                for (let i = startIndex; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;
                    const fields = parseCsvLine(line);
                    const rowType = (fields[0] || '').toLowerCase();
                    if (rowType === 'list') {
                        const listId = fields[1] || generateId();
                        const listName = fields[17] || fields[16] || `List ${listId}`;
                        const createdAt = fields[18] || new Date().toISOString();
                        importedLists.push({ id: listId, name: listName, createdAt });
                    } else if (rowType === 'card') {
                        const cardId = fields[1] || generateId();
                        const word = fields[2] || '';
                        const meaning = fields[3] || '';
                        const note = fields[4] || '';
                        const image = fields[5] || '';
                        const audio = fields[6] || '';
                        const practiced = (fields[7] || 'false').toLowerCase() === 'true';
                        const known = (fields[8] || 'false').toLowerCase() === 'true';
                        const timesShown = parseInt(fields[9]) || 0;
                        const correctCount = parseInt(fields[10]) || 0;
                        const wrongCount = parseInt(fields[11]) || 0;
                        const successRate = parseFloat(fields[12]) || 0;
                        const lastAskedAt = fields[13] || null;
                        const scheduleIndex = parseInt(fields[14]) || 0;
                        const nextDueAt = fields[15] || null;
                        const listId = fields[16] || currentListId || null;
                        importedCards.push({
                            id: cardId, word, meaning, note, image, audio, practiced, known, timesShown, correctCount, wrongCount, successRate, lastAskedAt, scheduleIndex, nextDueAt, listId
                        });
                    } else {
                        // ignore
                    }
                }
                if (!importedLists.length && !importedCards.length) { alert('No lists or cards detected in the CSV.'); return; }
                if (!confirm('Importing metadata will replace your current lists and cards. Continue?')) return;
                if (importedLists.length === 0) {
                    const uniqListIds = [...new Set(importedCards.map(c=>c.listId).filter(Boolean))];
                    if (uniqListIds.length > 0) {
                        uniqListIds.forEach(id => importedLists.push({ id, name: `List ${id}`, createdAt: new Date().toISOString() }));
                    } else {
                        importedLists.push({ id: generateId(), name: 'Default List', createdAt: new Date().toISOString() });
                        importedCards = importedCards.map(c => { if (!c.listId) c.listId = importedLists[0].id; return c; });
                    }
                }
                localStorage.setItem(LISTS_STORAGE_KEY, JSON.stringify(importedLists));
                localStorage.setItem(STORAGE_KEY, JSON.stringify(importedCards));
                if (importedLists.length > 0) localStorage.setItem(CURRENT_LIST_KEY, importedLists[0].id);
                init();
                alert('Metadata imported successfully!');
            };
            reader.readAsText(file);
        }
        // CSV parsing with quote handling
        function parseCsvLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    if (inQuotes && i + 1 < line.length && line[i + 1] === '"') {
                        current += '"'; i++;
                    } else inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(current); current = '';
                } else current += char;
            }
            result.push(current);
            return result;
        }

        function handleMetadataImport() {
            const input = document.getElementById('metadataFileInput');
            if (!input) return;
            input.value = '';
            input.focus();
            input.click();
        }

        function updateLanguageSelector() {
            const storedLanguage = localStorage.getItem('vocabularyFlashcardsLanguage');
            if (storedLanguage) document.getElementById('languageSelect').value = storedLanguage;
            applyTranslations();
        }
        function applyTranslations() {
            const language = document.getElementById('languageSelect').value;
            localStorage.setItem('vocabularyFlashcardsLanguage', language);
            // minimal translations (same as before)
            const texts = {
                en: { title:'Vocabulary Flashcards', subtitle:'Learn and practice vocabulary with spaced repetition', learnNewBtn:'Learn New Words', practiceLearnedBtn:'Practice Learned Words', viewStatsBtn:'View Statistics', importBtn:'Import Cards', exportMetadataBtn:'Export Metadata', importMetadataBtn:'Import Metadata', wipeAllBtn:'Wipe All Data', createListBtn:'Create New List', addSingleCardBtn:'Add Card', processImportBtn:'Process Import', backToDashboardBtn:'Back to Dashboard', summaryBtn:'Back to Dashboard', backFromStatsBtn:'Back to Dashboard', backFromImportBtn:'Back to Dashboard', availableNowFilter:'Available Now', neverPracticedFilter:'Never Practiced', knownWordsFilter:'Known Words', allCardsFilter:'All Cards', markKnownBtn:'Mark as Known', editNoteBtn:'Add Note', deleteCardBtn:'Delete Card' },
                pl: { title:'Fiszki Słownictwa', subtitle:'Ucz się i ćwicz słownictwo z powtórkami spaced', learnNewBtn:'Ucz się nowych słów', practiceLearnedBtn:'Ćwicz opanowane słowa', viewStatsBtn:'Pokaż statystyki', importBtn:'Importuj fiszki', exportMetadataBtn:'Eksportuj metadane', importMetadataBtn:'Importuj metadane', wipeAllBtn:'Usuń wszystkie dane', createListBtn:'Utwórz nową listę', addSingleCardBtn:'Dodaj fiszkę', processImportBtn:'Przetwórz import', backToDashboardBtn:'Powrót do pulpitu', summaryBtn:'Powrót do pulpitu', backFromStatsBtn:'Powrót do pulpitu', backFromImportBtn:'Powrót do pulpitu', availableNowFilter:'Dostępne teraz', neverPracticedFilter:'Nigdy nie ćwicze', knownWordsFilter:'Znane słowa', allCardsFilter:'Wszystkie fiszki', markKnownBtn:'Oznacz jako znane', editNoteBtn:'Dodaj notatkę', deleteCardBtn:'Usuń fiszkę' },
                tr: { title:'Kelime Kartları', subtitle:'Spaced repetition ile kelime öğrenin ve pratik yapın', learnNewBtn:'Yeni Kelimeler Öğren', practiceLearnedBtn:'Öğrenilenleri Pratik Yap', viewStatsBtn:'İstatistikleri Görüntüle', importBtn:'Kartları İçeri Aktar', exportMetadataBtn:'Metaveriyi Dışa Aktar', importMetadataBtn:'Metaveriyi İçe Aktar', wipeAllBtn:'Tüm Verileri Sil', createListBtn:'Yeni Liste Oluştur', addSingleCardBtn:'Kart Ekle', processImportBtn:'İçe Aktarımı İşle', backToDashboardBtn:'Panoya Dön', summaryBtn:'Panoya Dön', backFromStatsBtn:'Panoya Dön', backFromImportBtn:'Panoya Dön', availableNowFilter:'Şimdi Kullanılabilir', neverPracticedFilter:'Hiç Çalışılmadı', knownWordsFilter:'Bilinen Kelimeler', allCardsFilter:'Tüm Kartlar', markKnownBtn:'Bildi Olarak İşaretle', editNoteBtn:'Not Ekle', deleteCardBtn:'Kartı Sil' }
            };
            const t = texts[language] || texts.en;
            document.querySelector('h1').textContent = t.title;
            document.querySelector('header p').textContent = t.subtitle;
            document.getElementById('learnNewBtn').textContent = t.learnNewBtn;
            document.getElementById('practiceLearnedBtn').textContent = t.practiceLearnedBtn;
            document.getElementById('viewStatsBtn').textContent = t.viewStatsBtn;
            document.getElementById('importBtn').textContent = t.importBtn;
            document.getElementById('exportMetadataBtn').textContent = t.exportMetadataBtn;
            document.getElementById('importMetadataBtn').textContent = t.importMetadataBtn;
            document.getElementById('wipeAllBtn').textContent = t.wipeAllBtn;
            document.getElementById('createListBtn').textContent = t.createListBtn;
            document.getElementById('addSingleCardBtn').textContent = t.addSingleCardBtn;
            document.getElementById('processImportBtn').textContent = t.processImportBtn;
            document.getElementById('backToDashboardBtn').textContent = t.backToDashboardBtn;
            document.getElementById('summaryBtn').textContent = t.summaryBtn;
            document.getElementById('backFromStatsBtn').textContent = t.backFromStatsBtn;
            document.getElementById('backFromImportBtn').textContent = t.backFromImportBtn;
            document.getElementById('availableNowFilter').textContent = t.availableNowFilter;
            document.getElementById('neverPracticedFilter').textContent = t.neverPracticedFilter;
            document.getElementById('knownWordsFilter').textContent = t.knownWordsFilter;
            document.getElementById('allCardsFilter').textContent = t.allCardsFilter;
            document.getElementById('markKnownBtn').textContent = t.markKnownBtn;
            document.getElementById('editNoteBtn').textContent = t.editNoteBtn;
            document.getElementById('deleteCardBtn').textContent = t.deleteCardBtn;
        }

        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length -1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i+1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        // Side nav
        function openSideNav(){ sideNav.classList.add('open'); overlay.classList.add('show'); sideNav.setAttribute('aria-hidden','false'); document.body.style.overflow = 'hidden'; const firstInput = sideNav.querySelector('input, button'); if (firstInput) firstInput.focus(); }
        function closeSideNav(){ sideNav.classList.remove('open'); overlay.classList.remove('show'); sideNav.setAttribute('aria-hidden','true'); document.body.style.overflow = ''; if (burgerBtn) burgerBtn.focus(); }
        function toggleSideNav(){ if (sideNav.classList.contains('open')) closeSideNav(); else openSideNav(); }

        // Event listeners and wiring
        function setupEventListeners() {
            document.getElementById('learnNewBtn').addEventListener('click', startLearnSession);
            document.getElementById('practiceLearnedBtn').addEventListener('click', startPracticeSession);
            document.getElementById('viewStatsBtn').addEventListener('click', ()=> { showStatistics('availableNow'); showView('stats'); });
            document.getElementById('importBtn').addEventListener('click', ()=> showView('import'));
            document.getElementById('exportMetadataBtn').addEventListener('click', exportMetadata);
            document.getElementById('importMetadataBtn').addEventListener('click', handleMetadataImport);
            document.getElementById('wipeAllBtn').addEventListener('click', wipeAllData);
            document.getElementById('createListBtn').addEventListener('click', createNewList);
            document.getElementById('backToDashboardBtn').addEventListener('click', ()=> showView('dashboard'));
            document.getElementById('summaryBtn').addEventListener('click', ()=> showView('dashboard'));
            document.getElementById('backFromStatsBtn').addEventListener('click', ()=> showView('dashboard'));
            document.getElementById('backFromImportBtn').addEventListener('click', ()=> showView('dashboard'));
            document.getElementById('processImportBtn').addEventListener('click', ()=> {
                const fileInput = document.getElementById('fileInput');
                if (fileInput.files.length > 0) importCards(fileInput.files[0]);
                else alert('Please select a file to import.');
            });
            document.getElementById('processPasteBtn').addEventListener('click', ()=> {
                const content = document.getElementById('pasteInput').value;
                if (!content || content.trim() === '') { alert('Please paste word // meaning pairs into the text area before importing.'); return; }
                parseAndImport(content); document.getElementById('pasteInput').value = '';
            });
            document.getElementById('metadataFileInput').addEventListener('change', (e)=> { if (e.target.files.length > 0) importMetadata(e.target.files[0]); });
            document.getElementById('addSingleCardBtn').addEventListener('click', addSingleCard);
            document.getElementById('availableNowFilter').addEventListener('click', ()=> { setActiveFilter('availableNowFilter'); showStatistics('availableNow'); });
            document.getElementById('neverPracticedFilter').addEventListener('click', ()=> { setActiveFilter('neverPracticedFilter'); showStatistics('neverPracticed'); });
            document.getElementById('knownWordsFilter').addEventListener('click', ()=> { setActiveFilter('knownWordsFilter'); showStatistics('knownWords'); });
            document.getElementById('allCardsFilter').addEventListener('click', ()=> { setActiveFilter('allCardsFilter'); showStatistics('all'); });
            document.querySelectorAll('th[data-sort]').forEach(header => header.addEventListener('click', ()=> sortTable(header.dataset.sort)));
            document.getElementById('languageSelect').addEventListener('change', applyTranslations);
            document.getElementById('markKnownBtn').addEventListener('click', markCurrentCardAsKnown);
            document.getElementById('editNoteBtn').addEventListener('click', showNoteModal);
            document.getElementById('deleteCardBtn').addEventListener('click', deleteCurrentCard);
            saveNoteBtn.addEventListener('click', saveNote);
            cancelNoteBtn.addEventListener('click', closeNoteModal);
            noteModal.addEventListener('click', (e)=> { if (e.target === noteModal) closeNoteModal(); });
            const nightBtn = document.getElementById('nightModeToggle'); if (nightBtn) nightBtn.addEventListener('click', toggleNightMode);
            if (burgerBtn) burgerBtn.addEventListener('click', (e)=> { e.stopPropagation(); toggleSideNav(); });
            if (overlay) overlay.addEventListener('click', ()=> closeSideNav());
            document.addEventListener('keydown', (e)=> { if (e.key === 'Escape' && sideNav.classList.contains('open')) closeSideNav(); });
            sideNav.addEventListener('click', (e)=> e.stopPropagation());

            // Audio controls
            if (playAudioBtn) playAudioBtn.addEventListener('click', playAudioForCurrentCard);
            if (recordAudioBtn) recordAudioBtn.addEventListener('click', handleRecordButton);

            // Mark-known/delete buttons on stats are handled in showStatistics
        }

        function setActiveFilter(activeId) {
            document.querySelectorAll('.filter-btn').forEach(btn=> btn.classList.remove('active'));
            document.getElementById(activeId).classList.add('active');
        }

        // ---------- Audio: play / record ----------
        function updateAudioUIForCard(card) {
            // Play button visibility
            if (card && card.audio && card.audio.trim() !== '') {
                playAudioBtn.style.display = 'inline-flex';
                playAudioBtn.disabled = false;
            } else {
                playAudioBtn.style.display = 'none';
                playAudioBtn.disabled = true;
            }

            // Record button label: "Record" vs "Override Recording"
            if (card && card.audio && card.audio.trim() !== '') {
                recordAudioBtn.textContent = '🎙️ Override Recording';
                recordAudioBtn.title = 'Override existing recording';
            } else {
                recordAudioBtn.textContent = '🎙️ Record';
                recordAudioBtn.title = 'Record pronunciation';
            }
        }

        async function handleRecordButton() {
            // Toggle behaviour: start recording if not recording, otherwise stop and save
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                stopRecordingAndSave();
                return;
            }
            // Start recording
            try {
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    alert('Recording is not supported in this browser.');
                    return;
                }
                // request audio
                mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(mediaStream);
                recordedChunks = [];
                mediaRecorder.ondataavailable = function(e) {
                    if (e.data && e.data.size > 0) recordedChunks.push(e.data);
                };
                mediaRecorder.onstop = function() {
                    // convert to base64 data URL
                    const blob = new Blob(recordedChunks, { type: recordedChunks[0] ? recordedChunks[0].type : 'audio/webm' });
                    const reader = new FileReader();
                    reader.onloadend = function() {
                        const base64data = reader.result; // data:...base64...
                        // save to card
                        const card = currentSession.cards[currentSession.currentIndex];
                        if (card) {
                            card.audio = base64data;
                            saveCards();
                            updateAudioUIForCard(card);
                            // stop the media stream tracks
                            if (mediaStream) {
                                mediaStream.getTracks().forEach(t => t.stop());
                                mediaStream = null;
                            }
                            mediaRecorder = null;
                            recordedChunks = [];
                            alert('Recording saved.');
                        }
                    };
                    reader.readAsDataURL(blob);
                };
                mediaRecorder.start();
                // Update UI while recording
                recordAudioBtn.textContent = '⏹️ Stop & Save';
                recordAudioBtn.title = 'Stop and save recording';
            } catch (err) {
                console.error('Recording failed:', err);
                alert('Could not start recording. Please check microphone permissions and try again.');
            }
        }

        function stopRecordingAndSave() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
                // the onstop handler will save the data
                recordAudioBtn.textContent = 'Saving...';
                recordAudioBtn.disabled = true;
                // re-enable after small delay handled in onstop, but set a fallback
                setTimeout(()=> { recordAudioBtn.disabled = false; }, 1500);
            }
        }

        function playAudioForCurrentCard() {
            const card = currentSession.cards[currentSession.currentIndex];
            if (!card || !card.audio) {
                alert('No recording available for this card.');
                return;
            }
            try {
                const audio = new Audio(card.audio);
                audio.play().catch(err => {
                    console.error('Play failed:', err);
                    alert('Unable to play audio on this device/browser.');
                });
            } catch (err) {
                console.error('Play failed:', err);
                alert('Unable to play audio on this device/browser.');
            }
        }

        // ---------- End Audio ----------

        // Export/Import and other helper functions already implemented above

        // Initialize app
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
